

# Level to Volume

UnorderedMap <PriceLevel, Volume> 

- Volume int

O(1)



# Price Levels 

Unordered Map <Side, all price levels as a set> 

// Unordered Map <price, set::iterator>




# Cancel

username, orderid

order_dict : (username, orderid) -> (PriceLevel, LevelNode::iterator)

whole_linked_list.erase(iterator)

OrderBookSide.find(price) = log n


1. need to erase from order book
2. 





# Insert 

2. std::list<LevelNode>

struct LevelNode {
    OrderId order_id;
    std::string username;
    int volume;
}

struct PriceLevel {
    int price;
    Side side;
}


1. need to get the top of the order book

[2, 3, 4, 5, 6]

[1, 2, 3, 4, 5, 6]

OrderBook = map<PriceLevel, std::list<LevelNode>, CustomComparator>

         70 10

5 .      8
10 20    7

idea: go by level and then go by linkedlist node, and keep going until volume is finished

O(n)


asks, bids


# delete

// Assume that deleted orders are valid
auto const& [price_level, level_node_iter] = order_dict[std::make_pair(username, order_id)];


level = OrderBookSide.find(price_level).iter()
level.erase(level_node_iter);

subtract volume from level_to_volume

if (level.empty()) {
    OrderBookSide.erase(level)
    price_levels.erase(price_levels)
}

order_dict.erase(std::make_pair(username, order_id));







# insert

order_info = {}


OrderBookSide order_book = getOrderBookSide(Side);

while (it != order_book.end()):
    // Traverse the linked list
    if (side == 'B' && order.price_level < it.price_level)
        break

    if (side == 'S' && order.price_level > it.price_level)
        break
    
    while (order_info.volume > 0) {
        level_node = level.front();
        
        if (level_node.volume > order_volume) {
            level_node.volume -= order_volume;
            // update the level_to_volume
            // Insert a trade
            break
        }

        order_volume -= level_node.volume;

        // remove the level_node from the linked list
        // Insert a trade

        level.pop_front();

        // update the level to volume again

        // check if the level has been complete (i.e. has no nodes), if so, then delete level and advance the iterator to the next level in the orderbook
    }


    


// If still have order volume remaining, then insert it into the orderbook

